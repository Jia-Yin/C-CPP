\section{10603-3 數字龍捲風}

\subsection{解題思惟}
\begin{enumerate}
	\item 數字的讀取用二維陣列處理。
	\item 因為邊長n是奇數，所以中間的位置在n/2的地方。那輸出的順序要先找到規則，才能轉換成程式碼。基本上可以找到很多種不同的規則來處理，這邊提供兩種供參考。
	\item 第一種規則，從出發的方向開始，先走一格，接下來走的時候，總是先嘗試向右轉走，但如果右轉的數字已經讀取過，就改成直行。這樣就可以把所有數字讀完。另外因為要測試數字是否被讀取過，所以可另設一個同大小的二維陣列，把讀過的數字標記起來。至於什麼結束呢？可以設一個變數記錄已讀取的數目，如果已經到達$n\times n$就可以結束了。
	\item 第二種規則，從出發的方向開始，先走一格，接下來右轉走一格，接下來右轉走兩格，再右轉走兩格，接下來右轉走三格，再右轉走三格，依此類推，到最後右轉走n-1格兩次之後，最後再加上右轉走n-1格。
	\item 右轉和直行怎麼處理比較好呢？先談直行，基本上有上右下左四個方向，可以設定分別用0,1,2,3代表，那我們可以設一個水平位移陣列和垂直位移陣列來記錄四個方向的變化，例如往上移的話，水平位移是0，垂直位移是-1，其餘可類推。至於右轉的話，就是把目前代表的方向數字加1取4的餘數就可以了，例如目前如果往上，代表數字是0，加1之後為1，代表向右，餘可類推。
\end{enumerate}

\subsection{程式碼}
第一種規則：一直向右轉走，如果已經讀取過就改成直行。
\begin{cppcode}
#include <iostream>

using namespace std;

int main()
{
	int n, dir, cnt, dr[4]={0,-1,0,1}, dc[4]={-1,0,1,0};
	cin >> n >> dir; // 讀取 n 及方向
	int m[49][49], mark[49][49]={{0}}; // 數字陣列及記錄陣列
	for (int i=0; i<n; i++) {
		for (int j=0; j<n; j++) cin >> m[i][j]; // 讀取數字
	}
	int r=n/2, c=n/2; // 設定目前位置
	cout << m[r][c]; mark[r][c]=1; cnt=1; // 輸出原點、記錄、更新個數
	while (cnt<n*n) { // 尚未全部輸出時跑迴圈
		r+=dr[dir]; c+=dc[dir]; // 往目前方向走一格
		cout << m[r][c]; mark[r][c]=1; cnt++; // 輸出、記錄、更新個數
		// 嘗試新方向
		dir = (dir+1) % 4; // 右轉
		if (mark[r+dr[dir]][c+dc[dir]]) { // 如果右轉方向已標記過
			dir = (dir+3) % 4; // 左轉回原來方向
		}
	}
	cout << endl;
	return 0;
}
\end{cppcode}

第二種規則：從中心開始，每個方向跑兩次，並且跑的長度依次加1，最後一段要重覆再跑一次。
\begin{cppcode}
#include <iostream>

using namespace std;

int main()
{
	int a[49][49], n, dir, r, c;
	int dr[4]={0,-1,0,1}, dc[4]={-1,0,1,0};
	cin >> n >> dir;
	for (int r=0; r<n; r++) {
		for (int c=0; c<n; c++) cin >> a[r][c];
	}
	r=n/2; c=n/2; cout << a[r][c];
	for (int i=1; i<n; i++) { // 每段要走的長度i從1到n-1
		for (int j=0; j<2; j++) { // 走完一段再右轉一段共兩次
			for (int k=0; k<i; k++) { // 每段走的格數=i
				cr += dr[dir];  cc += dc[dir]; // 位移
				cout << a[cr][cc]; // 輸出
			}
			dir = (dir+1) % 4; // 右轉
		}
	}
	for (int k=0; k<n-1; k++) { // 最後一段要再走一遍
		cr += dr[dir];  cc += dc[dir];
		cout << a[cr][cc];
	}
	return 0;
}
\end{cppcode}
