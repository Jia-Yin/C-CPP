\section{10503-3 線段覆蓋長度}

\subsection{解題思惟}
\begin{enumerate}
	\item 這一題等於是要計算所有線段聯集之後覆蓋的長度。
	\item　因為所有線段的端點都是整數，我們可以使用一個比較基本的辦法，就是用陣列來代表整個範圍中出現的單位線段，那每次讀取一個線段，例如讀到線段[a,b]，我們就把a到b-1的位置全部標記起來。這樣一來，當所有線段都讀取完畢之後，我們只要計算總共被標記的位置有幾個就可以了。以下程式碼一即使用這個辦法。實際上測試時，會發現最後幾筆測資超時，表示計算複雜度還是太高。
	\item 這個題目最快的解法，稱為Klee's Algorithm，其演算法概念如下。首先將每個線段的端點值都存起來，而且要記錄是左端點還是右端點，這樣如果有n個線段的話，我們就會有2n個端點值。接著將這2n個值排序。排序好之後，從頭開始逐一巡訪每個端點值，兩個端點值之間都構成一個線段，如果這個線段在聯集中，就把它加總起來，如果不在聯集中，就跳過。那我們怎麼知道這個線段是不是在聯集中呢？我們從左往右逐一巡訪每個端點，如果這個端點是左端點，表示後面會有線段，如果這個端點是右端點，表示線段結束。那如果連續巡訪到兩個左端點，就表示目前有兩個線段還沒結束。所以我們可以這樣做，先宣告一個變數cnt=0，然後巡訪過程中，如果碰到左端點，就把cnt加1，表示目前多出現了一個線段，如果碰到右端點，就把cnt減1，表示減少了一個線段，這樣一來，只要目前的cnt為正，表示接下來的這個線段是在聯集中的，應該要加總；反之，如果cnt小於等於0，表示不在聯集中，不需加總，這樣問題就解決了。
	\item 在上面演算法中，排序的時候，是使用端點的值，但仍需保留該端點為左端點或右端點，一般來說要使用結構元素，其中包括數值和左右端點的旗標，然後針對結構元素排序。初學者如果對結構不熟，我們可以使用一個變通的辦法，我們把端點的數值乘以2，然後利用位元0來標記左端點或右端點，這樣的話對排序沒有影響，而且可以保留端點的類型。那排序好之後，把值除以2的整數商就是原先的端點值，把值除以2的餘數就是端點的類型，這樣就容易處理了。
\end{enumerate}

\subsection{程式碼}
程式碼一：使用陣列代表每個單位長度線段，並使用標記方式處理線段，無法通過所有測資。
\begin{cppcode}
#include <iostream>

using namespace std;

int main()
{
	int n, a, b, right=0;
	while (cin >> n) { // 假設有n筆測資
		int num[1000005]={0};
		for (int i=0; i<n; i++) {
			cin >> a >> b; // 讀取線段 
			for (int j=a; j<b; j++) num[j]=1; // 標記
			if (b>right) right=b; // 存取目前最右端的值
		}
		int sum=0;
		for (int i=0; i<right; i++) { // 檢視每個單位線段
			sum += num[i]; // 加總 (被標記的為1，未標記為0)
		}
		cout << sum << endl;
	}
	return 0;
}
\end{cppcode}

程式碼二：使用Klee's Algorithm。用來排序的端點值是原數值乘以2加上端點類型的值，此處設左端點為0，右端點為1。
\begin{cppcode}

#include <iostream>
#include <algorithm>

using namespace std;

int num[2*100005], n;

int main()
{
	int a, b;
	while (cin >> n) { // 讀取 n 值
		for (int i=0; i<n; i++) { // 讀取 n 個線段
			cin >> a >> b;
			num[2*i] = 2*a; // 左端點值，乘以2就好
			num[2*i+1] = 2*b+1; // 右端點值，乘以2加1
		}
		sort(num, num+2*n); // 端點值排序
		int sum=0, open=0; // open 用來計算目前的線段數
		for (int i=0; i<2*n; i++) {
			if (open>0) sum += num[i]/2-num[i-1]/2; // 在聯集中，應加總
			if (num[i]&1) open--; // 更新線段數，右減1
			else open++; // 更新線段數，左加1
		}
		cout << sum << endl;
	}
	return 0;
}
\end{cppcode}	
