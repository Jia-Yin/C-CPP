\section{A012 - 標準分解式}
輸入一正整數$N$, $N\ge 2$，輸出$N$的標準分解式。例如輸入12，則輸出2*2*3。

\subsection{解題思惟}
\begin{enumerate}
	\item 考慮因數的時候，設$p$從2開始一直到$N$，可以一一嘗試，看$p$是否為$N$的因數。
	\item 如果找到一個因數$p$，有可能$N$的這個因數有很多個，例如12有2個2的因數，所以當找到因數$p$的時候，把$N$變成$N/p$，再繼續嘗試看看除以$p$之後的$N$值是否還有$p$的因數，要一直試到沒有$p$的因數為止，然後再繼續檢查下一個數$p+1$。這可以寫一個while迴圈來處理，只要$p$還是$N$的因數，就一直除下去，把所有$p$的因數找出來，像下面這樣：
	\begin{inside}
	for (int p=2; p<=n; p++) {
		while (N%p == 0) {
			cout << "*" << p; 
			N /= p; 
		}
	}
	\end{inside}
	\item 或者另一個方法，就是當找到$p$是$N$的因數的時候，除了輸出$p$並且把$N$變成$N/p$之外，在主迴圈裡面不要把$p$加1，這樣重覆下一次迴圈的時候，$p$就會再被測試一次，這樣就可以把所有的因數$p$找出來。但是當$p$不是$N$的因數的時候，要記得把$p$加1，這樣才能繼續測試下一個數，像下面這樣：
	\begin{inside}
	for (int p=2; p<=n; ) { // 注意沒有更新式 p++
		if(n%p == 0) { // p是n的因數
			cout << "*" << p;
			n /= p; // 把因數p除掉，p仍維持原來的值
		} else p++; // p不是因數，把p加1
	}
	\end{inside}
	\item 如果$p<N$且$p$是$N$的因數，那麼$p$的因數也會是$N$的因數，所以在嘗試到$p$之前，$p$的因數應該都已經被找過了，而且更新過的$N$也已經除掉了所有$p$的因數。換句話說，當找到$p$是$N$的因數的時候，$p$應該沒有1和$p$以外的因數了，也就是$p$應該是質數，這樣一來，透過上面的程序，只要找到的$p$是$N$的因數，那一定也是質因數了。
	\item 第一個質因數不需要列印*號，其他的因數在列印之前要加上一個*號。這可以宣告一個first變數，一開始設為1，當列印過因數後，就把它設成0，然後在列印的時候，如果first為1，就不用列印*號，否則都要先列印*號。
\end{enumerate}
\subsection{程式碼}
\begin{cppcode}
#include <iostream>

using namespace std;

int main()
{
	int n, first=1;
	cin >> n;
	for (int p=2; p<=n; ) {
		if(n%p == 0) { // p是n的因數
			if(first) { cout<<p; first=0; }
			else cout << "*" << p;
			n /= p; // 把因數p除掉，p仍維持原來的值
		} else p++; // p不是因數，把p加1
	}
	return 0;
}
\end{cppcode}
